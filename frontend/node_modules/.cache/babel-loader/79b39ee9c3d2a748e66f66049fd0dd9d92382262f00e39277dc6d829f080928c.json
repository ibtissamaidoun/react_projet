{"ast":null,"code":"import { get as t, set as e } from \"react-hook-form\";\nconst s = (e, s, o) => {\n    if (e && \"reportValidity\" in e) {\n      const r = t(o, s);\n      e.setCustomValidity(r && r.message || \"\"), e.reportValidity();\n    }\n  },\n  o = (t, e) => {\n    for (const o in e.fields) {\n      const r = e.fields[o];\n      r && r.ref && \"reportValidity\" in r.ref ? s(r.ref, o, t) : r.refs && r.refs.forEach(e => s(e, o, t));\n    }\n  },\n  r = (s, r) => {\n    r.shouldUseNativeValidation && o(s, r);\n    const f = {};\n    for (const o in s) {\n      const n = t(r.fields, o),\n        a = Object.assign(s[o] || {}, {\n          ref: n && n.ref\n        });\n      if (i(r.names || Object.keys(s), o)) {\n        const s = Object.assign({}, t(f, o));\n        e(s, \"root\", a), e(f, o, s);\n      } else e(f, o, a);\n    }\n    return f;\n  },\n  i = (t, e) => t.some(t => t.startsWith(e + \".\"));\nexport { r as toNestErrors, o as validateFieldsNatively };","map":{"version":3,"mappings":";AASA,MAAMA,IAAoBA,CACxBC,GACAC,GACAC;IAEA,IAAIF,KAAO,oBAAoBA,GAAK;MAClC,MAAMG,IAAQC,EAAIF,GAAQD;MAC1BD,EAAID,kBAAmBI,KAASA,EAAME,WAAY,KAElDL,EAAIM,gBACN;IAAA;EAAA;EAIWC,IAAyBA,CACpCL,GACAM;IAEA,KAAK,MAAMP,KAAaO,EAAQC,QAAQ;MACtC,MAAMC,IAAQF,EAAQC,OAAOR;MACzBS,KAASA,EAAMV,OAAO,oBAAoBU,EAAMV,MAClDD,EAAkBW,EAAMV,KAAKC,GAAWC,KAC/BQ,EAAMC,QACfD,EAAMC,KAAKC,QAASZ,KAClBD,EAAkBC,GAAKC,GAAWC,GAGxC;IAAA;EAAA;ECzBWW,IAAeA,CAC1BX,GACAM;IAEAA,EAAQM,6BAA6BP,EAAuBL,GAAQM;IAEpE,MAAMO,IAAc;IACpB,KAAK,MAAMC,KAAQd,GAAQ;MACzB,MAAMQ,IAAQN,EAAII,EAAQC,QAAQO;QAC5Bb,IAAQc,OAAOC,OAAOhB,EAAOc,MAAS,IAAI;UAC9ChB,KAAKU,KAASA,EAAMV;QAAAA;MAGtB,IAAImB,EAAmBX,EAAQY,SAASH,OAAOI,KAAKnB,IAASc,IAAO;QAClE,MAAMM,IAAmBL,OAAOC,OAAO,IAAId,EAAIW,GAAaC;QAE5DO,EAAID,GAAkB,QAAQnB,IAC9BoB,EAAIR,GAAaC,GAAMM,EACzB;MAAA,OACEC,EAAIR,GAAaC,GAAMb,EAE3B;IAAA;IAEA,OAAOY;EAAAA;EAGHI,IAAqBA,CACzBC,GACAI,MACGJ,EAAMK,KAAMC,KAAMA,EAAEC,WAAWH,IAAO;AAAA","names":["setCustomValidity","ref","fieldPath","errors","error","get","message","reportValidity","validateFieldsNatively","options","fields","field","refs","forEach","toNestErrors","shouldUseNativeValidation","fieldErrors","path","Object","assign","isNameInFieldArray","names","keys","fieldArrayErrors","set","name","some","n","startsWith"],"sources":["C:\\Users\\Dell\\expense-tracker_fullstack\\frontend\\node_modules\\@hookform\\resolvers\\src\\validateFieldsNatively.ts","C:\\Users\\Dell\\expense-tracker_fullstack\\frontend\\node_modules\\@hookform\\resolvers\\src\\toNestErrors.ts"],"sourcesContent":["import {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Ref,\n  ResolverOptions,\n  get,\n} from 'react-hook-form';\n\nconst setCustomValidity = (\n  ref: Ref,\n  fieldPath: string,\n  errors: FieldErrors,\n) => {\n  if (ref && 'reportValidity' in ref) {\n    const error = get(errors, fieldPath) as FieldError | undefined;\n    ref.setCustomValidity((error && error.message) || '');\n\n    ref.reportValidity();\n  }\n};\n\n// Native validation (web only)\nexport const validateFieldsNatively = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): void => {\n  for (const fieldPath in options.fields) {\n    const field = options.fields[fieldPath];\n    if (field && field.ref && 'reportValidity' in field.ref) {\n      setCustomValidity(field.ref, fieldPath, errors);\n    } else if (field.refs) {\n      field.refs.forEach((ref: HTMLInputElement) =>\n        setCustomValidity(ref, fieldPath, errors),\n      );\n    }\n  }\n};\n","import {\n  Field,\n  FieldErrors,\n  FieldValues,\n  InternalFieldName,\n  ResolverOptions,\n  get,\n  set,\n} from 'react-hook-form';\nimport { validateFieldsNatively } from './validateFieldsNatively';\n\nexport const toNestErrors = <TFieldValues extends FieldValues>(\n  errors: FieldErrors,\n  options: ResolverOptions<TFieldValues>,\n): FieldErrors<TFieldValues> => {\n  options.shouldUseNativeValidation && validateFieldsNatively(errors, options);\n\n  const fieldErrors = {} as FieldErrors<TFieldValues>;\n  for (const path in errors) {\n    const field = get(options.fields, path) as Field['_f'] | undefined;\n    const error = Object.assign(errors[path] || {}, {\n      ref: field && field.ref,\n    });\n\n    if (isNameInFieldArray(options.names || Object.keys(errors), path)) {\n      const fieldArrayErrors = Object.assign({}, get(fieldErrors, path));\n\n      set(fieldArrayErrors, 'root', error);\n      set(fieldErrors, path, fieldArrayErrors);\n    } else {\n      set(fieldErrors, path, error);\n    }\n  }\n\n  return fieldErrors;\n};\n\nconst isNameInFieldArray = (\n  names: InternalFieldName[],\n  name: InternalFieldName,\n) => names.some((n) => n.startsWith(name + '.'));\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}