{"ast":null,"code":"import { validateFieldsNatively as r, toNestErrors as e } from \"@hookform/resolvers\";\nimport { appendErrors as o } from \"react-hook-form\";\nvar n = function (r, e) {\n    for (var n = {}; r.length;) {\n      var t = r[0],\n        s = t.code,\n        i = t.message,\n        a = t.path.join(\".\");\n      if (!n[a]) if (\"unionErrors\" in t) {\n        var u = t.unionErrors[0].errors[0];\n        n[a] = {\n          message: u.message,\n          type: u.code\n        };\n      } else n[a] = {\n        message: i,\n        type: s\n      };\n      if (\"unionErrors\" in t && t.unionErrors.forEach(function (e) {\n        return e.errors.forEach(function (e) {\n          return r.push(e);\n        });\n      }), e) {\n        var c = n[a].types,\n          f = c && c[t.code];\n        n[a] = o(a, e, n, s, f ? [].concat(f, t.message) : t.message);\n      }\n      r.shift();\n    }\n    return n;\n  },\n  t = function (o, t, s) {\n    return void 0 === s && (s = {}), function (i, a, u) {\n      try {\n        return Promise.resolve(function (e, n) {\n          try {\n            var a = Promise.resolve(o[\"sync\" === s.mode ? \"parse\" : \"parseAsync\"](i, t)).then(function (e) {\n              return u.shouldUseNativeValidation && r({}, u), {\n                errors: {},\n                values: s.raw ? i : e\n              };\n            });\n          } catch (r) {\n            return n(r);\n          }\n          return a && a.then ? a.then(void 0, n) : a;\n        }(0, function (r) {\n          if (function (r) {\n            return Array.isArray(null == r ? void 0 : r.errors);\n          }(r)) return {\n            values: {},\n            errors: e(n(r.errors, !u.shouldUseNativeValidation && \"all\" === u.criteriaMode), u)\n          };\n          throw r;\n        }));\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    };\n  };\nexport { t as zodResolver };","map":{"version":3,"mappings":";;AAKA,IAGMA,IAAmB,UACvBC,GACAC;IAGA,KADA,IAAMC,IAAqC,CAAE,GACtCF,EAAUG,SAAU;MACzB,IAAMC,IAAQJ,EAAU;QAChBK,IAAwBD,EAAxBC;QAAMC,IAAkBF,EAAlBE;QACRC,IAD0BH,EAATI,KACJC,KAAK;MAExB,KAAKP,EAAOK,IACV,IAAI,iBAAiBH,GAAO;QAC1B,IAAMM,IAAaN,EAAMO,YAAY,GAAGT,OAAO;QAE/CA,EAAOK,KAAS;UACdD,SAASI,EAAWJ;UACpBM,MAAMF,EAAWL;QAAAA,CAErB;MAAA,OACEH,EAAOK,KAAS;QAAED;QAASM,MAAMP;MAAAA;MAUrC,IANI,iBAAiBD,KACnBA,EAAMO,YAAYE,QAAQ,UAACH;QAAU,OACnCA,EAAWR,OAAOW,QAAQ,UAACC;UAAM,SAAUC,KAAKD,EAAE;QAAA,EAAC;MAAA,IAInDb,GAA0B;QAC5B,IAAMe,IAAQd,EAAOK,GAAOS;UACtBC,IAAWD,KAASA,EAAMZ,EAAMC;QAEtCH,EAAOK,KAASW,EACdX,GACAN,GACAC,GACAG,GACAY,IACK,GAAgBE,OAAOF,GAAsBb,EAAME,WACpDF,EAAME,QAEd;MAAA;MAEAN,EAAUoB,OACZ;IAAA;IAEA,OAAOlB,CACT;EAAA;EAEamB,IACX,UAACC,GAAQC,GAAeC;IACjBC,YADgC,MAAfD,UAAkB,CAAE,IACrCC,aAAQC,GAAGC;MAAW;QAAA;UAAAC;YAAAA,QACvBC,gBACiBP,EACQ,WAAzBE,EAAgBM,OAAkB,UAAU,cAC5CL,GAAQF,IAAcQ,KAFlBC;cAMN,OAFAL,EAAQM,6BAA6BC,EAAuB,IAAIP,IAEzD;gBACLzB,QAAQ,CAAiB;gBACzBuB,QAAQD,EAAgBW,MAAMV,IAASO;cAAAA,CACvC;YAAA;UAAA;YAAA;UAAA;UAAA;QAAA,CAXuBI,CACvB,GAWH,UAAQhC;UACP,IApEa,UAACA;YAClB,aAAMiC,QAAa,QAALjC,SAAK,IAALA,EAAOF,OAAO;UAAA,CAmEpBoC,CAAWlC,IACb,OAAO;YACLqB,QAAQ;YACRvB,QAAQqC,EACNxC,EACEK,EAAMF,SACLyB,EAAQM,6BACkB,UAAzBN,EAAQa,eAEZb;UAAAA;UAKN,MAAMvB,CACR;QAAA,GACF;MAAA,CAAC;QAAA;MAAA;IAAA;EAAA;AAAA","names":["parseErrorSchema","zodErrors","validateAllFieldCriteria","errors","length","error","code","message","_path","path","join","unionError","unionErrors","type","forEach","e","push","types","messages","appendErrors","concat","shift","zodResolver","schema","schemaOptions","resolverOptions","values","_","options","resolve","Promise","mode","then","data","shouldUseNativeValidation","validateFieldsNatively","raw","_catch","isArray","isZodError","toNestErrors","criteriaMode"],"sources":["C:\\Users\\Dell\\expense-tracker_fullstack\\frontend\\node_modules\\@hookform\\resolvers\\zod\\src\\zod.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport { FieldError, FieldErrors, appendErrors } from 'react-hook-form';\nimport { ZodError, z } from 'zod';\nimport type { Resolver } from './types';\n\nconst isZodError = (error: any): error is ZodError =>\n  Array.isArray(error?.errors);\n\nconst parseErrorSchema = (\n  zodErrors: z.ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) => {\n  const errors: Record<string, FieldError> = {};\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if ('unionErrors' in error) {\n        const unionError = error.unionErrors[0].errors[0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if ('unionErrors' in error) {\n      error.unionErrors.forEach((unionError) =>\n        unionError.errors.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n};\n\nexport const zodResolver: Resolver =\n  (schema, schemaOptions, resolverOptions = {}) =>\n  async (values, _, options) => {\n    try {\n      const data = await schema[\n        resolverOptions.mode === 'sync' ? 'parse' : 'parseAsync'\n      ](values, schemaOptions);\n\n      options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n      return {\n        errors: {} as FieldErrors,\n        values: resolverOptions.raw ? values : data,\n      };\n    } catch (error: any) {\n      if (isZodError(error)) {\n        return {\n          values: {},\n          errors: toNestErrors(\n            parseErrorSchema(\n              error.errors,\n              !options.shouldUseNativeValidation &&\n                options.criteriaMode === 'all',\n            ),\n            options,\n          ),\n        };\n      }\n\n      throw error;\n    }\n  };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}